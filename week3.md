# DAY1 2023-04-10 129-143

## 130. Backups and restore methods

* backing up resource configuration
* query kube API server -> save all resource configuration
* Or backup ETCD cluster -> backup ETCD and make a snashot with etcdctl

```
export ETCDCTL_API=3 -----> v2 does not have snapshot command
etcdctl snapshot save -h
--cacert
--cert
--endpoints=[127.0.0.1:2345]
--key
# etcdctl snapshot save /opt/snapshot-pre-boot.db --cacert="/etc/kubernetes/pki/etcd/ca.crt" --cert="/etc/kubernetes/pki/etcd/server.crt" --key="/etc/kubernetes/pki/etcd/server.key" --endpoints=127.0.0.1:2379
Snapshot saved at /opt/snapshot-pre-boot.db
```
```
etcdctl snapshot restore --data-dir /var/lib/etcd-from-backup /opt/snapshot-pre-boot.db

volumes: -hostPath: path: -> change /var/lib/etcd-from-backup -> etcd will be restarted
```

## Kubernetes Security Primitives

* Kube API server is the first line for security
* Who can access / What can they do

* who can access -> authentication
* what can they do - RBAC authorization, ABAC, node, webhook...
* All communications between various modules in master/workder nodes are encrypted with TLS.
* network policy - controll access between Pods

## Authentication

* Kube supports serviceaccount - what is it?
* User = Admin + Developer
* Admin: mainly use kubectl
* Developer: mainly use Kube APIs 
* Both goes to Kube-apiserver -> kube-apiserver does authentication
* Authentication with statis password file, statkc token file, Cerificates, 3rd parth protocol

* Static password file
* make scv file with passord,usename,permission
* run `kube-apiserver --basic-auth-file=user-details.csv`
* add `-u "user:password"` to curl
* We can add group field to password file

* token file user-token-detail.csv
* run `kube-apiserver --token-auth-file=user-detail.csv`
* add `--header "Authorization: Bearer <token>"` to curl
  
* NOT RECOMENDED

# DAY2 2023-04-11 144-152

## TLS Basics

* guarantee trust between two during a transaction
* eg)encrypt communication between user and server

## 145. TLS in Kubernetes

* All communications need to be secure.

* kube-apiserver is a server for some clients: Admin user, kube-scheduler, kube-controller-manager, kube-proxy
* All components have own pair of certificate and key.
* Between kube-apiserver and etcd, kube-apiserver is a client and etcd server is a server.


## 146. Certificate Creation

* Use openssl tool among various tools

CA certificates
* create client key `openssl genrsa -out ca.key 2048` => ca.key
* generate a certificate signing request `openssl req -new -key ca.key -subj "/CN=KUBERNETES-CA" -out ca.csr` => ca.csr
* Sign certificates `openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt` => ca.crt

Admin User
* `openssl genrsa -out admin.key 2048` => admin.key
* `openssl req -new -key admin.key -subj "/CN=kube-admin/O=system:masters" -out admin.csr` => admin.csr
* `openssl x509 -req -in admin.csr -CA ca.crt -CAkey ca.key -out admin.crt` => admin.crt generated by CA certificates
* `/O=system:masters` => only for admin

* When using API
```
curl https://kube-apiserver:6443/api/v1/pods --key admin.key --cert admin.crt --cacert ca.crt
```

* kube-config.yaml for default setting
```
apiVersion: v1
clusters:
- cluster
    certificate-authority: ca.crt
    server: https://kube-apiserver:6443
  name: kubernetes
kind: Config
users:
- name: kubernetes-admin
  user:
    client-certificate: admin.crt
    client-key: admin.key
```

* kube-apiserver is called : kubernetes, kubernetes.default, kubernetes.default.svc, kubernetes.default.svc.cluster.local or IP address
* kube-apiserver needs client and server certificates.
* 

## 147. View Certificate Details

* kubeadm: see /etc/kubernetes/manifests/kube-apiserver.yaml: spec.containers.command
* command parameters: client-ca-file, etcd-cafile, etcd-certfile, etcd-keyfile => access etcd
* tls parameters: tls-cert-file, tls-private-key

* see API server certificate file /etc/kubernetes/pki/apiserver.crt
```
openssl x509 -in /etc/kubernetes/pki/apiserver.crt -text -noout
...
Subject: CN=kube-apiserver
...
Alternative Name:
...
```


# DAY3 2023-04-12 153-162


## KubeConfig

* $HOME/.kube/config: define certificates options for kubectl by default, no need to specify the path when using kubectl
* three sections: Clusters, Contexts, Users
* Contexts: which user uses which cluster
```
apiVersion: v1
kind: Config
current-context: my-kube-admin@my-kube-play
clusters:
- name: my-kube-play
  cluster:
    certificate-authority: ca.crt
    server: https://my-kube-play:6443
contexts:
- name: my-kube-admin@my-kube-play
  context:
    cluster: my-kube-play
    user: my-kube-admin
    namespace: finance ======> optional, set default namespace
users:
- name: my-kube-admin
  user:
    client-certificate: admin.crt
    client-key: admin.key
```

`kubectl config view`

`kubectl config use-context another-user@another-cluster` => change current-context in config file


# DAY4 2023-04-12 163-173


# DAY5 2023-04-13 174-185

## Network Policy

* Allow ingress traffic from API Pod on Port 3306

```
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: db-policy
spec:
  podSelector:
    matchLabels:
      role: db =======> apply this rule to this Pod
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
      matchLabels:
        name: api-pod =====> allow traffic from this pod
    ports:
    - protocol: TCP
      port: 3306
```
```
kubectl create -f policy-definition.yml
```


## 176. Develoing network policies

```
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: db-policy
spec:
  podSelector:
    matchLabels:
      role: db
  policyTypes:
  - Ingress
  ingress:
  - from
    - podSelector: ========> specify pod. If no podSelector, all pod in the specified namespace are allowed.
        matchLabels:
          name: api-pod
      namespaceSelector: ====> specify namespace of pod-selector. Otherwise all namespaces are allowed. 
        matchLabels:
          name: prod
    - ipBlock:
      cidr: 192.168.5.10/32 ===> allowed IP range
      except:
      - 17.117.1.0/24 ==========> blocked IP range
    ports:
    - protocol: TCP
      port: 3306
  egress:
  - to:
    - ipBlock:
      cidr: 192.168.5.10/32
    ports:
    - protocol: TCP
      port: 80
```


Below is one rule: match-labels AND match-namespace
```
    - podSelector: ========> specify pod. If no podSelector, all pod in the specified namespace are allowed.
        matchLabels:
          name: api-pod
      namespaceSelector: ====> specify namespace of pod-selector. Otherwise all namespaces are allowed. 
        matchLabels:
          name: prod
```


Below is TWO rules: match-labels OR match-namespace
```
    - podSelector: ========> specify pod. If no podSelector, all pod in the specified namespace are allowed.
        matchLabels:
          name: api-pod
    - namespaceSelector: ====> specify namespace of pod-selector. Otherwise all namespaces are allowed. 
        matchLabels:
          name: prod
```


Egress example
```
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: internal-policy
  namespace: default
spec:
  egress:
  - to:
    - podSelector:
        matchLabels:
          name: mysql
    - podSelector:
        matchLabels:
          name: payroll
    ports:
    - port: 3306
      protocol: TCP
    - port: 8080
      protocol: TCP
  podSelector:
    matchLabels:
      name: internal
  policyTypes:
  - Egress
```

## 182 Storage in Docker



## 183 Volume Driver Plugins in Docker



## 184 Container Storage Interface (CSI)





